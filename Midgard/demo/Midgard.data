in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

uniform vec3 uniMinCloudsArea;
uniform vec3 uniMaxCloudsArea;
uniform sampler3D uniNoiseMap;

layout(location = 0) out vec4 fragColor;

vec3 remap(vec3 value, vec3 low1, vec3 high1, vec3 low2, vec3 high2) {
  return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
}

void main() {
  vec3 rayDir = normalize(vertMeshInfo.vertPosition - uniCameraPos);
  vec3 rayPos = vertMeshInfo.vertPosition;
  float depthStep = 10.0;

  float value = 0.0;

  for (int i = 0; i < 10; ++i) {
    rayPos += rayDir * 10.0;

    //vec3 texcoords = remap(rayPos, uniMinCloudsArea, uniMaxCloudsArea, vec3(0.0), vec3(1.0));
    vec3 texcoords = (rayPos - uniMinCloudsArea) * 1.0 / (uniMaxCloudsArea - uniMinCloudsArea);

//    if (texcoords.x < 0.0 || texcoords.x > 1.0
//     || texcoords.y < 0.0 || texcoords.y > 1.0
//     || texcoords.z < 0.0 || texcoords.z > 1.0)
//      value += 1.0;

    float noise = texture(uniNoiseMap, texcoords).r;

    if (noise > 0.5)
      value += 0.1;
  }

  fragColor = vec4(vec3(value), 1.0);
}
#define MAX_LIGHT_COUNT 100
#define PI 3.1415926535897932384626433832795

struct Light {
  vec4 position;
  vec4 direction;
  vec4 color;
  float energy;
  float angle;
};

struct Material {
  vec3 baseColor;
  vec3 emissive;
  float metallicFactor;
  float roughnessFactor;

  sampler2D baseColorMap;
  sampler2D emissiveMap;
  sampler2D normalMap;
  sampler2D metallicMap;
  sampler2D roughnessMap;
  sampler2D ambientMap; // Ambient occlusion
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

in vec3 vertColor;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

layout(std140) uniform uboLightsInfo {
  Light uniLights[MAX_LIGHT_COUNT];
  uint uniLightCount;
};

uniform Material uniMaterial;

layout(location = 0) out vec4 fragColor;
layout(location = 1) out vec3 bufferNormal;

// Normal Distribution Function: Trowbridge-Reitz GGX
float computeNormalDistrib(vec3 normal, vec3 halfVec, float roughness) {
  float sqrRough  = roughness * roughness;
  float frthRough = sqrRough * sqrRough;

  float halfVecAngle    = max(dot(halfVec, normal), 0.0);
  float sqrHalfVecAngle = halfVecAngle * halfVecAngle;

  float divider = (sqrHalfVecAngle * (frthRough - 1.0) + 1.0);
  divider       = PI * divider * divider;

  return frthRough / max(divider, 0.001);
}

// Fresnel: Shlick
vec3 computeFresnel(float cosTheta, vec3 baseReflectivity) {
  // Optimized exponent version, from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
  return baseReflectivity + (1.0 - baseReflectivity) * pow(2.0, (-5.55473 * cosTheta - 6.98316) * cosTheta);
}

// Shlick-Beckmann for Geometry part
float computeGeomShlickGGX(float angle, float roughness) {
  float incrRough   = (roughness + 1.0);
  float roughFactor = (incrRough * incrRough) / 8.0;

  float denom = angle * (1.0 - roughFactor) + roughFactor;

  return angle / denom;
}

// Geometry: Smith's Shlick GGX
float computeGeometry(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness) {
  float viewAngle  = max(dot(viewDir, normal), 0.0);
  float lightAngle = max(dot(lightDir, normal), 0.0);

  float viewGeom  = computeGeomShlickGGX(viewAngle, roughness);
  float lightGeom = computeGeomShlickGGX(lightAngle, roughness);

  return viewGeom * lightGeom;
}

void main() {
  vec3 albedo     = pow(vertColor, vec3(2.2));
  float metallic  = texture(uniMaterial.metallicMap, vertMeshInfo.vertTexcoords).r * uniMaterial.metallicFactor;
  float roughness = texture(uniMaterial.roughnessMap, vertMeshInfo.vertTexcoords).r * uniMaterial.roughnessFactor;
  float ambOcc    = texture(uniMaterial.ambientMap, vertMeshInfo.vertTexcoords).r;

  vec3 normal = texture(uniMaterial.normalMap, vertMeshInfo.vertTexcoords).rgb;
  normal      = normalize(normal * 2.0 - 1.0);
  normal      = normalize(vertMeshInfo.vertTBNMatrix * normal);

  vec3 viewDir = normalize(uniCameraPos - vertMeshInfo.vertPosition);

  // Base Fresnel (F)
  vec3 baseReflectivity = mix(vec3(0.04), albedo, metallic);

  vec3 albedoFactor = albedo / PI;

  vec3 lightRadiance = vec3(0.0);

  for (uint lightIndex = 0u; lightIndex < uniLightCount; ++lightIndex) {
    vec3 fullLightDir;
    float attenuation = uniLights[lightIndex].energy;

    if (uniLights[lightIndex].position.w != 0.0) {
      fullLightDir = uniLights[lightIndex].position.xyz - vertMeshInfo.vertPosition;

      float sqrDist = dot(fullLightDir, fullLightDir);
      attenuation  /= sqrDist;
    } else {
      fullLightDir = -uniLights[lightIndex].direction.xyz;
    }

    vec3 lightDir = normalize(fullLightDir);
    vec3 halfDir  = normalize(viewDir + lightDir);
    vec3 radiance = uniLights[lightIndex].color.rgb * attenuation;

    // Normal distrib (D)
    float normalDistrib = computeNormalDistrib(normal, halfDir, roughness);

    // Fresnel (F)
    vec3 fresnel = computeFresnel(max(dot(halfDir, viewDir), 0.0), baseReflectivity);

    // Geometry (G)
    float geometry = computeGeometry(normal, viewDir, lightDir, roughness);

    vec3 DFG         = normalDistrib * fresnel * geometry;
    float lightAngle = max(dot(lightDir, normal), 0.0);
    float divider    = 4.0 * max(dot(viewDir, normal), 0.0) * lightAngle;
    vec3 specular    = DFG / max(divider, 0.001);

    vec3 diffuse = vec3(1.0) - fresnel;
    diffuse     *= 1.0 - metallic;

    lightRadiance += (diffuse * albedoFactor + specular) * radiance * lightAngle;
  }

  vec3 ambient  = vec3(0.03) * albedo * ambOcc;
  vec3 emissive = texture(uniMaterial.emissiveMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.emissive;
  vec3 color    = ambient + lightRadiance + emissive;

  // HDR tone mapping
  color = color / (color + vec3(1.0));
  // Gamma correction
  color = pow(color, vec3(1.0 / 2.2));

  fragColor = vec4(color, metallic);

  // Sending fragment normal to next framebuffer(s), if any
  bufferNormal = normal;
}
struct Buffers {
  sampler2D depth;
  sampler2D color;
};

in vec2 fragTexcoords;

layout(std140) uniform uboCameraMatrices {
  mat4 viewMat;
  mat4 invViewMat;
  mat4 projectionMat;
  mat4 invProjectionMat;
  mat4 viewProjectionMat;
  vec3 cameraPos;
};

uniform Buffers uniSceneBuffers;
uniform vec3 uniSunDir;
uniform float uniFogDensity;

layout(location = 0) out vec4 fragColor;

vec3 computeViewPosFromDepth(float depth) {
  vec4 projPos = vec4(vec3(fragTexcoords, depth) * 2.0 - 1.0, 1.0);
  vec4 viewPos = invProjectionMat * projPos;

  return viewPos.xyz / viewPos.w;
}

// Basic fog implementation from https://www.iquilezles.org/www/articles/fog/fog.htm
vec3 computeFog(vec3 color, float distance, vec3 viewDir) {
  float fogDensity = uniFogDensity / 20.0;
  float fogAmount  = 1.0 - exp(-distance * fogDensity);

  float sunAmount = max(-dot(viewDir, mat3(viewMat) * uniSunDir), 0.0);
  vec3 fogColor   = mix(vec3(0.5, 0.6, 0.7), // Sky/fog color (blue)
                        vec3(1.0, 0.9, 0.7), // Sun color (yellow)
                        pow(sunAmount, 8.0));

  return mix(color, fogColor, fogAmount);
}

void main() {
  float depth = texture(uniSceneBuffers.depth, fragTexcoords).r;
  vec3 color  = texture(uniSceneBuffers.color, fragTexcoords).rgb;

  vec3 viewPos     = computeViewPosFromDepth(depth);
  float viewDist   = length(viewPos);
  vec3 foggedColor = computeFog(color, viewDist, viewPos / viewDist);

  fragColor = vec4(foggedColor, 1.0);
}
layout(local_size_x = 1, local_size_y = 1, local_size_x = 1) in;

layout(r16f, binding = 0) uniform writeonly image2D uniNoiseMap;
uniform float uniNoiseFactor = 0.01;
uniform int uniOctaveCount   = 1;

const int permutations[512] = int[](
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
);

const vec2 gradients2D[8] = vec2[](
  vec2(         1.0,           0.0), vec2(         -1.0,           0.0),
  vec2(         0.0,           1.0), vec2(          0.0,          -1.0),
  vec2(0.7071067691,  0.7071067691), vec2(-0.7071067691,  0.7071067691),
  vec2(0.7071067691, -0.7071067691), vec2(-0.7071067691, -0.7071067691)
);

float smootherstep(float value) {
  return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);
}

vec2 recoverGradient2D(int x, int y) {
  return gradients2D[permutations[permutations[x] + y] % gradients2D.length()];
}

float computePerlin(vec2 coords) {
  // Recovering integer coordinates on the quad
  //
  //  y0+1______x0+1/y0+1
  //     |      |
  //     |      |
  // x0/y0______x0+1

  int intX = int(coords.x);
  int intY = int(coords.y);

  int x0 = intX & 255;
  int y0 = intY & 255;

  // Recovering pseudo-random gradients at each corner of the quad
  vec2 leftBotGrad  = recoverGradient2D(x0,     y0    );
  vec2 rightBotGrad = recoverGradient2D(x0 + 1, y0    );
  vec2 leftTopGrad  = recoverGradient2D(x0,     y0 + 1);
  vec2 rightTopGrad = recoverGradient2D(x0 + 1, y0 + 1);

  // Computing the distance to the coordinates
  //  _____________
  //  |           |
  //  | xWeight   |
  //  |---------X |
  //  |         | yWeight
  //  |_________|_|

  float xWeight = coords.x - float(intX);
  float yWeight = coords.y - float(intY);

  float leftBotDot  = dot(vec2(xWeight,       yWeight      ), leftBotGrad);
  float rightBotDot = dot(vec2(xWeight - 1.0, yWeight      ), rightBotGrad);
  float leftTopDot  = dot(vec2(xWeight,       yWeight - 1.0), leftTopGrad);
  float rightTopDot = dot(vec2(xWeight - 1.0, yWeight - 1.0), rightTopGrad);

  float smoothX = smootherstep(xWeight);
  float smoothY = smootherstep(yWeight);

  float botCoeff = mix(leftBotDot, rightBotDot, smoothX);
  float topCoeff = mix(leftTopDot, rightTopDot, smoothX);

  return mix(botCoeff, topCoeff, smoothY);
}

float computeFbm(vec2 coords, int octaveCount) {
  float frequency = 1.0;
  float amplitude = 1.0;
  float total     = 0.0;

  for (int i = 0; i < octaveCount; ++i) {
    total += computePerlin(coords * frequency) * amplitude;

    frequency *= 2.0;
    amplitude *= 0.5;
  }

  return (total + 1.0) / 2.0;
}

void main() {
  float noise = computeFbm(vec2(gl_GlobalInvocationID.xy) * uniNoiseFactor, uniOctaveCount);

  ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
  imageStore(uniNoiseMap, pixelCoords, vec4(vec3(noise), 1.0));
}
layout(local_size_x = 1, local_size_y = 1, local_size_x = 1) in;

layout(r16f, binding = 0) uniform writeonly image3D uniNoiseMap;
uniform float uniNoiseFactor = 0.01;
uniform int uniOctaveCount   = 1;

const int permutations[512] = int[](
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
);

// Only 12 gradients are necessary; however, 16 are defined to avoid dividing by 12. These form a regular tetrahedron, thus no bias is introduced
const vec3 gradients3D[16] = vec3[](
  vec3(0.7071067691,  0.7071067691,           0.0), vec3(-0.7071067691,  0.7071067691,           0.0),
  vec3(0.7071067691, -0.7071067691,           0.0), vec3(-0.7071067691, -0.7071067691,           0.0),
  vec3(0.7071067691,           0.0,  0.7071067691), vec3(-0.7071067691,           0.0,  0.7071067691),
  vec3(0.7071067691,           0.0, -0.7071067691), vec3(-0.7071067691,           0.0, -0.7071067691),
  vec3(         0.0,  0.7071067691,  0.7071067691), vec3(          0.0, -0.7071067691,  0.7071067691),
  vec3(         0.0,  0.7071067691, -0.7071067691), vec3(          0.0, -0.7071067691, -0.7071067691),
  vec3(0.7071067691,  0.7071067691,           0.0), vec3(-0.7071067691,  0.7071067691,           0.0),
  vec3(         0.0, -0.7071067691,  0.7071067691), vec3(          0.0, -0.7071067691, -0.7071067691)
);

float smootherstep(float value) {
  return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);
}

vec3 recoverGradient3D(int x, int y, int z) {
  return gradients3D[permutations[permutations[permutations[x] + y] + z] % gradients3D.length()];
}

float computePerlin(vec3 coords) {
  // Recovering integer coordinates on the cube

  int intX = int(coords.x);
  int intY = int(coords.y);
  int intZ = int(coords.z);

  int x0 = intX & 255;
  int y0 = intY & 255;
  int z0 = intZ & 255;

  // Recovering pseudo-random gradients at each corner of the quad
  vec3 leftBotBackGrad   = recoverGradient3D(x0,     y0,     z0    );
  vec3 leftBotFrontGrad  = recoverGradient3D(x0,     y0,     z0 + 1);
  vec3 rightBotBackGrad  = recoverGradient3D(x0 + 1, y0,     z0    );
  vec3 rightBotFrontGrad = recoverGradient3D(x0 + 1, y0,     z0 + 1);
  vec3 leftTopBackGrad   = recoverGradient3D(x0,     y0 + 1, z0    );
  vec3 leftTopFrontGrad  = recoverGradient3D(x0,     y0 + 1, z0 + 1);
  vec3 rightTopBackGrad  = recoverGradient3D(x0 + 1, y0 + 1, z0    );
  vec3 rightTopFrontGrad = recoverGradient3D(x0 + 1, y0 + 1, z0 + 1);

  // Computing the distance to the coordinates
  //     _____________
  //    /           /|
  //   /           / |
  //  /___________/ X|
  //  |           |/ |
  //  | xWeight   / zWeight
  //  |---------X |  /
  //  |         | yWeight
  //  |_________|_|/

  float xWeight = coords.x - float(intX);
  float yWeight = coords.y - float(intY);
  float zWeight = coords.z - float(intZ);

  float leftBotBackDot   = dot(vec3(xWeight,       yWeight      , zWeight      ), leftBotBackGrad);
  float leftBotFrontDot  = dot(vec3(xWeight,       yWeight      , zWeight - 1.0), leftBotFrontGrad);
  float rightBotBackDot  = dot(vec3(xWeight - 1.0, yWeight      , zWeight      ), rightBotBackGrad);
  float rightBotFrontDot = dot(vec3(xWeight - 1.0, yWeight      , zWeight - 1.0), rightBotFrontGrad);
  float leftTopBackDot   = dot(vec3(xWeight,       yWeight - 1.0, zWeight      ), leftTopBackGrad);
  float leftTopFrontDot  = dot(vec3(xWeight,       yWeight - 1.0, zWeight - 1.0), leftTopFrontGrad);
  float rightTopBackDot  = dot(vec3(xWeight - 1.0, yWeight - 1.0, zWeight      ), rightTopBackGrad);
  float rightTopFrontDot = dot(vec3(xWeight - 1.0, yWeight - 1.0, zWeight - 1.0), rightTopFrontGrad);

  float smoothX = smootherstep(xWeight);
  float smoothY = smootherstep(yWeight);
  float smoothZ = smootherstep(zWeight);

  float botBackCoeff  = mix(leftBotBackDot,  rightBotBackDot,  smoothX);
  float botFrontCoeff = mix(leftBotFrontDot, rightBotFrontDot, smoothX);
  float topBackCoeff  = mix(leftTopBackDot,  rightTopBackDot,  smoothX);
  float topFrontCoeff = mix(leftTopFrontDot, rightTopFrontDot, smoothX);

  float backCoeff  = mix(botBackCoeff,  topBackCoeff,  smoothY);
  float frontCoeff = mix(botFrontCoeff, topFrontCoeff, smoothY);

  return mix(backCoeff, frontCoeff, smoothZ);
}

float computeFbm(vec3 coords, int octaveCount) {
  float frequency = 1.0;
  float amplitude = 1.0;
  float total     = 0.0;

  for (int i = 0; i < octaveCount; ++i) {
    total += computePerlin(coords * frequency) * amplitude;

    frequency *= 2.0;
    amplitude *= 0.5;
  }

  return (total + 1.0) / 2.0;
}

void main() {
  float noise = computeFbm(vec3(gl_GlobalInvocationID.xyz) * uniNoiseFactor, uniOctaveCount);

  ivec3 pixelCoords = ivec3(gl_GlobalInvocationID.xyz);
  imageStore(uniNoiseMap, pixelCoords, vec4(vec3(noise), 1.0));
}
layout(vertices = 4) out;

struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
};

in MeshInfo vertMeshInfo[];

layout(std140) uniform uboCameraMatrices {
  mat4 viewMat;
  mat4 invViewMat;
  mat4 projectionMat;
  mat4 invProjectionMat;
  mat4 viewProjectionMat;
  vec3 cameraPos;
};

uniform float uniTessLevel = 12.0;

out MeshInfo tessMeshInfo[];

void main() {
  gl_out[gl_InvocationID].gl_Position         = gl_in[gl_InvocationID].gl_Position;
  tessMeshInfo[gl_InvocationID].vertPosition  = vertMeshInfo[gl_InvocationID].vertPosition;
  tessMeshInfo[gl_InvocationID].vertTexcoords = vertMeshInfo[gl_InvocationID].vertTexcoords;
  tessMeshInfo[gl_InvocationID].vertTBNMatrix = vertMeshInfo[gl_InvocationID].vertTBNMatrix;

  if (gl_InvocationID == 0) {
    vec3 patchCentroid    = (vertMeshInfo[0].vertPosition + vertMeshInfo[1].vertPosition + vertMeshInfo[2].vertPosition + vertMeshInfo[3].vertPosition) / 4.0;
    float tessLevelFactor = (1.0 / distance(cameraPos, patchCentroid)) * 512.0;

    // Outer levels get a higher factor in order to attempt filling gaps between patches
    // TODO: A better way must be found, like varying the level according the edges mid points
    //   See: https://www.khronos.org/opengl/wiki/Tessellation#Patch_interface_and_continuity
    gl_TessLevelOuter[0] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[1] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[2] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[3] = uniTessLevel * (tessLevelFactor * 4.0);

    gl_TessLevelInner[0] = uniTessLevel * tessLevelFactor;
    gl_TessLevelInner[1] = uniTessLevel * tessLevelFactor;
  }
}
layout(quads, fractional_odd_spacing, ccw) in;

struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
};

in MeshInfo tessMeshInfo[];

uniform sampler2D uniNoiseMap;
uniform uvec2 uniTerrainSize;
uniform float uniFlatness     = 3.0;
uniform float uniHeightFactor = 30.0;

layout(std140) uniform uboCameraMatrices {
  mat4 viewMat;
  mat4 invViewMat;
  mat4 projectionMat;
  mat4 invProjectionMat;
  mat4 viewProjectionMat;
  vec3 cameraPos;
};

out MeshInfo vertMeshInfo;

vec3 computeNormalDifferences(vec2 vertUV) {
  float uStride = 1.0 / float(uniTerrainSize.x);
  float vStride = 1.0 / float(uniTerrainSize.y);

  float topHeight   = pow(texture(uniNoiseMap, vertUV + vec2(     0.0, -vStride)).r, uniFlatness) * uniHeightFactor;
  float leftHeight  = pow(texture(uniNoiseMap, vertUV + vec2(-uStride,      0.0)).r, uniFlatness) * uniHeightFactor;
  float rightHeight = pow(texture(uniNoiseMap, vertUV + vec2( uStride,      0.0)).r, uniFlatness) * uniHeightFactor;
  float botHeight   = pow(texture(uniNoiseMap, vertUV + vec2(     0.0,  vStride)).r, uniFlatness) * uniHeightFactor;

  // Replace y by 2.0-2.5 to get the same result as the cross method
  return normalize(vec3(leftHeight - rightHeight, 1.0, topHeight - botHeight));
}

vec3 computeNormalCross(vec3 vertPos, vec2 vertUV) {
  float uStride = 1.0 / float(uniTerrainSize.x);
  float vStride = 1.0 / float(uniTerrainSize.y);

  vec3 bottomLeftPos  = vertPos + vec3(-1.0, 0.0, -1.0);
  vec3 topLeftPos     = vertPos + vec3(-1.0, 0.0,  1.0);
  vec3 bottomRightPos = vertPos + vec3( 1.0, 0.0, -1.0);
  vec3 topRightPos    = vertPos + vec3( 1.0, 0.0,  1.0);

  float bottomLeftNoise  = texture(uniNoiseMap, vertUV + vec2(-uStride, -vStride)).r;
  float topLeftNoise     = texture(uniNoiseMap, vertUV + vec2(-uStride,  vStride)).r;
  float bottomRightNoise = texture(uniNoiseMap, vertUV + vec2( uStride, -vStride)).r;
  float topRightNoise    = texture(uniNoiseMap, vertUV + vec2( uStride,  vStride)).r;

  bottomLeftPos.y  += pow(bottomLeftNoise, uniFlatness) * uniHeightFactor;
  topLeftPos.y     += pow(topLeftNoise, uniFlatness) * uniHeightFactor;
  bottomRightPos.y += pow(bottomRightNoise, uniFlatness) * uniHeightFactor;
  topRightPos.y    += pow(topRightNoise, uniFlatness) * uniHeightFactor;

  vec3 bottomLeftDir  = bottomLeftPos - vertPos;
  vec3 topLeftDir     = topLeftPos - vertPos;
  vec3 bottomRightDir = bottomRightPos - vertPos;
  vec3 topRightDir    = topRightPos - vertPos;

  vec3 normal = cross(bottomLeftDir, topLeftDir);
  normal     += cross(topRightDir, bottomRightDir);
  normal     += cross(bottomRightDir, bottomLeftDir);
  normal     += cross(topLeftDir, topRightDir);

  return normalize(normal);
}

void main() {
  // Top & bottom are actually inverted when looking the terrain from above: [0] & [2] are the patch's top vertices, while [1] & [3] are the bottom's
  vec3 bottomLeftPos  = tessMeshInfo[0].vertPosition;
  vec3 topLeftPos     = tessMeshInfo[1].vertPosition;
  vec3 bottomRightPos = tessMeshInfo[2].vertPosition;
  vec3 topRightPos    = tessMeshInfo[3].vertPosition;

  // Interpolating bilinearly to recover the position on the patch
  vec3 vertPos0 = mix(tessMeshInfo[0].vertPosition, tessMeshInfo[1].vertPosition, gl_TessCoord.x);
  vec3 vertPos1 = mix(tessMeshInfo[2].vertPosition, tessMeshInfo[3].vertPosition, gl_TessCoord.x);
  vec3 vertPos  = mix(vertPos0, vertPos1, gl_TessCoord.y);

  // Interpolating bilinearly to recover the texcoords on the patch
  vec2 vertUV0 = mix(tessMeshInfo[0].vertTexcoords, tessMeshInfo[1].vertTexcoords, gl_TessCoord.x);
  vec2 vertUV1 = mix(tessMeshInfo[2].vertTexcoords, tessMeshInfo[3].vertTexcoords, gl_TessCoord.x);
  vec2 vertUV  = mix(vertUV0, vertUV1, gl_TessCoord.y);

  float midNoise = texture(uniNoiseMap, vertUV).r;
  vertPos.y += pow(midNoise, uniFlatness) * uniHeightFactor;

  vec3 normal = computeNormalDifferences(vertUV);
  //vec3 normal = computeNormalCross(vertPos, vertUV);
  vec3 tangent = normal.zxy; // ?

  vertMeshInfo.vertPosition  = vertPos;
  vertMeshInfo.vertTexcoords = vertUV;
  vertMeshInfo.vertTBNMatrix = mat3(tangent, cross(normal, tangent), normal);

  gl_Position = viewProjectionMat * vec4(vertPos, 1.0);
}
layout(vertices = 4) out;

struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
};

in MeshInfo vertMeshInfo[];

layout(std140) uniform uboCameraMatrices {
  mat4 viewMat;
  mat4 invViewMat;
  mat4 projectionMat;
  mat4 invProjectionMat;
  mat4 viewProjectionMat;
  vec3 cameraPos;
};

uniform float uniTessLevel = 12.0;

out MeshInfo tessMeshInfo[];

void main() {
  gl_out[gl_InvocationID].gl_Position         = gl_in[gl_InvocationID].gl_Position;
  tessMeshInfo[gl_InvocationID].vertPosition  = vertMeshInfo[gl_InvocationID].vertPosition;
  tessMeshInfo[gl_InvocationID].vertTexcoords = vertMeshInfo[gl_InvocationID].vertTexcoords;
  tessMeshInfo[gl_InvocationID].vertTBNMatrix = vertMeshInfo[gl_InvocationID].vertTBNMatrix;

  if (gl_InvocationID == 0) {
    vec3 patchCentroid    = (vertMeshInfo[0].vertPosition + vertMeshInfo[1].vertPosition + vertMeshInfo[2].vertPosition + vertMeshInfo[3].vertPosition) / 4.0;
    float tessLevelFactor = (1.0 / distance(cameraPos, patchCentroid)) * 512.0;

    // Outer levels get a higher factor in order to attempt filling gaps between patches
    // TODO: A better way must be found, like varying the level according the edges mid points
    //   See: https://www.khronos.org/opengl/wiki/Tessellation#Patch_interface_and_continuity
    gl_TessLevelOuter[0] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[1] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[2] = uniTessLevel * (tessLevelFactor * 4.0);
    gl_TessLevelOuter[3] = uniTessLevel * (tessLevelFactor * 4.0);

    gl_TessLevelInner[0] = uniTessLevel * tessLevelFactor;
    gl_TessLevelInner[1] = uniTessLevel * tessLevelFactor;
  }
}
layout(quads, fractional_odd_spacing, ccw) in;

struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
};

in MeshInfo tessMeshInfo[];

uniform sampler2D uniNoiseMap;
uniform uvec2 uniWaterSize;
uniform float uniHeightFactor = 1.0;
uniform float uniTime;

layout(std140) uniform uboCameraMatrices {
  mat4 viewMat;
  mat4 invViewMat;
  mat4 projectionMat;
  mat4 invProjectionMat;
  mat4 viewProjectionMat;
  vec3 cameraPos;
};

out MeshInfo vertMeshInfo;
out vec3 vertColor;

vec3 computeNormalDifferences(vec2 vertUV) {
  float uStride = 1.0 / float(uniWaterSize.x);
  float vStride = 1.0 / float(uniWaterSize.y);

  float topHeight   = texture(uniNoiseMap, vertUV + vec2(     0.0, -vStride)).r * uniHeightFactor;
  float leftHeight  = texture(uniNoiseMap, vertUV + vec2(-uStride,      0.0)).r * uniHeightFactor;
  float rightHeight = texture(uniNoiseMap, vertUV + vec2( uStride,      0.0)).r * uniHeightFactor;
  float botHeight   = texture(uniNoiseMap, vertUV + vec2(     0.0,  vStride)).r * uniHeightFactor;

  // Replace y by 2.0-2.5 to get the same result as the cross method
  return normalize(vec3(leftHeight - rightHeight, 1.0, topHeight - botHeight));
}

vec3 computeNormalCross(vec3 vertPos, vec2 vertUV) {
  float uStride = 1.0 / float(uniWaterSize.x);
  float vStride = 1.0 / float(uniWaterSize.y);

  vec3 bottomLeftPos  = vertPos + vec3(-1.0, 0.0, -1.0);
  vec3 topLeftPos     = vertPos + vec3(-1.0, 0.0,  1.0);
  vec3 bottomRightPos = vertPos + vec3( 1.0, 0.0, -1.0);
  vec3 topRightPos    = vertPos + vec3( 1.0, 0.0,  1.0);

  float bottomLeftNoise  = texture(uniNoiseMap, vertUV + vec2(-uStride, -vStride)).r;
  float topLeftNoise     = texture(uniNoiseMap, vertUV + vec2(-uStride,  vStride)).r;
  float bottomRightNoise = texture(uniNoiseMap, vertUV + vec2( uStride, -vStride)).r;
  float topRightNoise    = texture(uniNoiseMap, vertUV + vec2( uStride,  vStride)).r;

  bottomLeftPos.y  += bottomLeftNoise * uniHeightFactor;
  topLeftPos.y     += topLeftNoise * uniHeightFactor;
  bottomRightPos.y += bottomRightNoise * uniHeightFactor;
  topRightPos.y    += topRightNoise * uniHeightFactor;

  vec3 bottomLeftDir  = bottomLeftPos - vertPos;
  vec3 topLeftDir     = topLeftPos - vertPos;
  vec3 bottomRightDir = bottomRightPos - vertPos;
  vec3 topRightDir    = topRightPos - vertPos;

  vec3 normal = cross(bottomLeftDir, topLeftDir);
  normal     += cross(topRightDir, bottomRightDir);
  normal     += cross(bottomRightDir, bottomLeftDir);
  normal     += cross(topLeftDir, topRightDir);

  return normalize(normal);
}

void main() {
  // Top & bottom are actually inverted when looking the terrain from above: [0] & [2] are the patch's top vertices, while [1] & [3] are the bottom's
  vec3 bottomLeftPos  = tessMeshInfo[0].vertPosition;
  vec3 topLeftPos     = tessMeshInfo[1].vertPosition;
  vec3 bottomRightPos = tessMeshInfo[2].vertPosition;
  vec3 topRightPos    = tessMeshInfo[3].vertPosition;

  // Interpolating bilinearly to recover the position on the patch
  vec3 vertPos0 = mix(tessMeshInfo[0].vertPosition, tessMeshInfo[1].vertPosition, gl_TessCoord.x);
  vec3 vertPos1 = mix(tessMeshInfo[2].vertPosition, tessMeshInfo[3].vertPosition, gl_TessCoord.x);
  vec3 vertPos  = mix(vertPos0, vertPos1, gl_TessCoord.y);

  // Interpolating bilinearly to recover the texcoords on the patch
  vec2 vertUV0 = mix(tessMeshInfo[0].vertTexcoords, tessMeshInfo[1].vertTexcoords, gl_TessCoord.x);
  vec2 vertUV1 = mix(tessMeshInfo[2].vertTexcoords, tessMeshInfo[3].vertTexcoords, gl_TessCoord.x);
  vec2 vertUV  = mix(vertUV0, vertUV1, gl_TessCoord.y);

  float midNoise = texture(uniNoiseMap, vertUV).r;
  vertPos.y += midNoise * uniHeightFactor;

  vec3 normal = computeNormalDifferences(vertUV);
  //vec3 normal = computeNormalCross(vertPos, vertUV);
  vec3 tangent = normal.zxy; // ?

  vertMeshInfo.vertPosition  = vertPos;
  vertMeshInfo.vertTexcoords = vertUV;
  vertMeshInfo.vertTBNMatrix = mat3(tangent, cross(normal, tangent), normal);

  vertColor = vec3(0.0, 0.0, 1.0);

  gl_Position = viewProjectionMat * vec4(vertPos, 1.0);
}
#define MAX_LIGHT_COUNT 100

struct Light {
  vec4 position;
  vec4 direction;
  vec4 color;
  float energy;
  float angle;
};

struct Material {
  vec3 baseColor;
  vec3 emissive;
  vec3 ambient;
  vec3 specular;
  float transparency;

  sampler2D baseColorMap;
  sampler2D emissiveMap;
  sampler2D ambientMap;
  sampler2D specularMap;
  sampler2D transparencyMap;
  sampler2D bumpMap;
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

layout(std140) uniform uboLightsInfo {
  Light uniLights[MAX_LIGHT_COUNT];
  uint uniLightCount;
};

uniform Material uniMaterial;

layout(location = 0) out vec4 fragColor;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec4 fragSpecular;

void main() {
  vec3 color      = texture(uniMaterial.baseColorMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.baseColor;
  vec3 specFactor = texture(uniMaterial.specularMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.specular;
  vec3 normal     = vertMeshInfo.vertTBNMatrix[2];
  vec3 viewDir    = normalize(uniCameraPos - vertMeshInfo.vertPosition);

  vec3 diffuse  = vec3(0.0);
  vec3 specular = vec3(0.0);

  for (uint lightIndex = 0u; lightIndex < uniLightCount; ++lightIndex) {
    vec3 fullLightDir;
    float attenuation = uniLights[lightIndex].energy;

    if (uniLights[lightIndex].position.w != 0.0) {
      fullLightDir = uniLights[lightIndex].position.xyz - vertMeshInfo.vertPosition;

      float sqDist = dot(fullLightDir, fullLightDir);
      attenuation /= sqDist;
    } else {
      fullLightDir = -uniLights[lightIndex].direction.xyz;
    }

    vec3 lightDir = normalize(fullLightDir);
    vec3 radiance = uniLights[lightIndex].color.rgb * attenuation;

    // Diffuse
    float lightAngle = max(dot(lightDir, normal), 0.0);
    diffuse         += color * lightAngle * radiance;

    // Specular
    vec3 halfDir    = normalize(viewDir + lightDir);
    float halfAngle = max(dot(halfDir, normal), 0.0);
    specular       += specFactor * pow(halfAngle, 32.0) * radiance;
  }

  vec3 ambient  = color * 0.05;
  vec3 emissive = texture(uniMaterial.emissiveMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.emissive;

  fragColor    = vec4(ambient + diffuse + specular + emissive, 1.0);
  fragNormal   = normal * 0.5 + 0.5;
  fragSpecular = vec4(specFactor, 1.0 - max(specFactor.x, max(specFactor.y, specFactor.z)));
}
in vec2 fragTexcoords;

uniform sampler2D uniBuffer;
uniform vec2 uniInvBufferSize;
uniform int uniKernelSize; // Technically half the size, but for name simplicity...

layout(location = 0) out vec4 fragColor;

void main() {
  vec3 result = vec3(0.0);

  for (int i = -uniKernelSize; i < uniKernelSize; ++i) {
    for (int j = -uniKernelSize; j < uniKernelSize; ++j) {
      vec2 offset = vec2(float(i), float(j)) * uniInvBufferSize;
      result += texture(uniBuffer, fragTexcoords + offset).rgb;
    }
  }

  int kernelFullSize = uniKernelSize * 2;
  fragColor = vec4(result / float(kernelFullSize * kernelFullSize), 1.0);
}
in vec2 fragTexcoords;

uniform sampler2D uniBuffer;
uniform vec2 uniInvBufferSize;
uniform float uniStrength;
uniform vec2 uniDirection;
uniform sampler2D uniMask;

layout(location = 0) out vec4 fragColor;

void main() {
  vec3 color  = texture(uniBuffer, fragTexcoords).rgb;
  vec2 offset = uniDirection * uniInvBufferSize * uniStrength;

  float red   = texture(uniBuffer, fragTexcoords - offset).r;
  float green = color.g;
  float blue  = texture(uniBuffer, fragTexcoords + offset).b;

  vec3 mask = texture(uniMask, fragTexcoords).rgb;

  fragColor = vec4(mix(color, vec3(red, green, blue), mask), 1.0);
}
layout(location = 0) in vec3 vertPosition;
layout(location = 1) in vec2 vertTexcoords;
layout(location = 2) in vec3 vertNormal;
layout(location = 3) in vec3 vertTangent;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

layout(std140) uniform uboModelInfo {
  mat4 uniModelMat;
};

out struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

void main() {
  vertMeshInfo.vertPosition  = (uniModelMat * vec4(vertPosition, 1.0)).xyz;
  vertMeshInfo.vertTexcoords = vertTexcoords;

  mat3 modelMat = mat3(uniModelMat);

  vec3 tangent   = normalize(modelMat * vertTangent);
  vec3 normal    = normalize(modelMat * vertNormal);
  vec3 bitangent = cross(normal, tangent);
  vertMeshInfo.vertTBNMatrix = mat3(tangent, bitangent, normal);

  gl_Position = uniViewProjectionMat * uniModelMat * vec4(vertPosition, 1.0);
}
in vec2 fragTexcoords;

uniform sampler2D uniBuffer;
uniform vec2 uniInvBufferSize;
uniform float[9] uniKernel;

layout(location = 0) out vec4 fragColor;

// The following "matrix" is transposed compared to the common offsets list; this is due to the kernel matrix supposedly being sent as column-major,
//   thus not matching the usual indices used to access the offsets (kernel[i][j] would correspond to offset[j][i])
const vec2[9] offsets = vec2[](
  vec2(-1.0, 1.0), vec2(-1.0, 0.0), vec2(-1.0, -1.0),
  vec2( 0.0, 1.0), vec2( 0.0, 0.0), vec2( 0.0, -1.0),
  vec2( 1.0, 1.0), vec2( 1.0, 0.0), vec2( 1.0, -1.0)
);

void main() {
  vec3 result = vec3(0.0);

  for (int i = 0; i < 9; ++i) {
    vec2 offset = offsets[i] * uniInvBufferSize;
    result += texture(uniBuffer, fragTexcoords + offset).rgb * vec3(uniKernel[i]);
  }

  fragColor = vec4(result, 1.0);
}
#define MAX_LIGHT_COUNT 100
#define PI 3.1415926535897932384626433832795

struct Light {
  vec4 position;
  vec4 direction;
  vec4 color;
  float energy;
  float angle;
};

struct Material {
  vec3 baseColor;
  vec3 emissive;
  float metallicFactor;
  float roughnessFactor;

  sampler2D baseColorMap;
  sampler2D emissiveMap;
  sampler2D normalMap;
  sampler2D metallicMap;
  sampler2D roughnessMap;
  sampler2D ambientMap; // Ambient occlusion
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

layout(std140) uniform uboLightsInfo {
  Light uniLights[MAX_LIGHT_COUNT];
  uint uniLightCount;
};

uniform Material uniMaterial;

layout(location = 0) out vec4 fragColor;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec4 fragSpecular;

// Normal Distribution Function: Trowbridge-Reitz GGX
float computeNormalDistrib(vec3 normal, vec3 halfVec, float roughness) {
  float sqrRough  = roughness * roughness;
  float frthRough = sqrRough * sqrRough;

  float halfVecAngle    = max(dot(halfVec, normal), 0.0);
  float sqrHalfVecAngle = halfVecAngle * halfVecAngle;

  float divider = (sqrHalfVecAngle * (frthRough - 1.0) + 1.0);
  divider       = PI * divider * divider;

  return frthRough / max(divider, 0.001);
}

// Fresnel: Shlick
vec3 computeFresnel(float cosTheta, vec3 baseReflectivity) {
  // Optimized exponent version, from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
  return baseReflectivity + (1.0 - baseReflectivity) * pow(2.0, (-5.55473 * cosTheta - 6.98316) * cosTheta);
}

// Shlick-Beckmann for Geometry part
float computeGeomShlickGGX(float angle, float roughness) {
  float incrRough   = (roughness + 1.0);
  float roughFactor = (incrRough * incrRough) / 8.0;

  float denom = angle * (1.0 - roughFactor) + roughFactor;

  return angle / denom;
}

// Geometry: Smith's Shlick GGX
float computeGeometry(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness) {
  float viewAngle  = max(dot(viewDir, normal), 0.0);
  float lightAngle = max(dot(lightDir, normal), 0.0);

  float viewGeom  = computeGeomShlickGGX(viewAngle, roughness);
  float lightGeom = computeGeomShlickGGX(lightAngle, roughness);

  return viewGeom * lightGeom;
}

void main() {
  // Gamma correction for albedo (sRGB presumed)
  vec3 albedo     = pow(texture(uniMaterial.baseColorMap, vertMeshInfo.vertTexcoords).rgb, vec3(2.2)) * uniMaterial.baseColor;
  float metallic  = texture(uniMaterial.metallicMap, vertMeshInfo.vertTexcoords).r * uniMaterial.metallicFactor;
  float roughness = texture(uniMaterial.roughnessMap, vertMeshInfo.vertTexcoords).r * uniMaterial.roughnessFactor;
  float ambOcc    = texture(uniMaterial.ambientMap, vertMeshInfo.vertTexcoords).r;

  vec3 normal = texture(uniMaterial.normalMap, vertMeshInfo.vertTexcoords).rgb;
  normal      = normalize(normal * 2.0 - 1.0);
  normal      = normalize(vertMeshInfo.vertTBNMatrix * normal);

  vec3 viewDir = normalize(uniCameraPos - vertMeshInfo.vertPosition);

  // Base Fresnel (F0)
  vec3 baseReflectivity = mix(vec3(0.04), albedo, metallic);

  vec3 albedoFactor = albedo / PI;

  vec3 lightRadiance = vec3(0.0);

  for (uint lightIndex = 0u; lightIndex < uniLightCount; ++lightIndex) {
    vec3 fullLightDir;
    float attenuation = uniLights[lightIndex].energy;

    if (uniLights[lightIndex].position.w != 0.0) {
      fullLightDir = uniLights[lightIndex].position.xyz - vertMeshInfo.vertPosition;

      float sqDist = dot(fullLightDir, fullLightDir);
      attenuation /= sqDist;
    } else {
      fullLightDir = -uniLights[lightIndex].direction.xyz;
    }

    vec3 lightDir = normalize(fullLightDir);
    vec3 halfDir  = normalize(viewDir + lightDir);
    vec3 radiance = uniLights[lightIndex].color.rgb * attenuation;

    // Normal distribution (D)
    float normalDistrib = computeNormalDistrib(normal, halfDir, roughness);

    // Fresnel (F)
    vec3 fresnel = computeFresnel(max(dot(halfDir, viewDir), 0.0), baseReflectivity);

    // Geometry (G)
    float geometry = computeGeometry(normal, viewDir, lightDir, roughness);

    vec3 DFG         = normalDistrib * fresnel * geometry;
    float lightAngle = max(dot(lightDir, normal), 0.0);
    float divider    = 4.0 * max(dot(viewDir, normal), 0.0) * lightAngle;
    vec3 specular    = DFG / max(divider, 0.001);

    vec3 diffuse = vec3(1.0) - fresnel;
    diffuse     *= 1.0 - metallic;

    lightRadiance += (diffuse * albedoFactor + specular) * radiance * lightAngle;
  }

  vec3 ambient  = vec3(0.03) * albedo * ambOcc;
  vec3 emissive = texture(uniMaterial.emissiveMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.emissive;
  vec3 color    = ambient + lightRadiance + emissive;

  // HDR tone mapping
  color = color / (color + vec3(1.0));
  // Gamma correction
  color = pow(color, vec3(1.0 / 2.2));

  fragColor    = vec4(color, 1.0);
  fragNormal   = normal * 0.5 + 0.5;
  fragSpecular = vec4(baseReflectivity, roughness);
}
in vec2 fragTexcoords;

uniform sampler2D uniBuffer;
uniform vec2 uniInvBufferSize;
uniform vec2 uniBlurDirection;

layout(location = 0) out vec4 fragColor;

const float kernelOffsets[3] = float[](0.0, 1.3846153846, 3.2307692308);
const float kernelWeights[3] = float[](0.2270270270, 0.3162162162, 0.0702702703);

void main() {
  vec3 blurredColor = texture(uniBuffer, gl_FragCoord.xy * uniInvBufferSize).rgb * kernelWeights[0];

  for (int i = 1; i < 3; ++i) {
    blurredColor += texture(uniBuffer, (gl_FragCoord.xy + kernelOffsets[i] * uniBlurDirection) * uniInvBufferSize).rgb * kernelWeights[i];
    blurredColor += texture(uniBuffer, (gl_FragCoord.xy - kernelOffsets[i] * uniBlurDirection) * uniInvBufferSize).rgb * kernelWeights[i];
  }

  fragColor = vec4(blurredColor, 1.0);
}
#define MAX_LIGHT_COUNT 100

struct Light {
  vec4 position;
  vec4 direction;
  vec4 color;
  float energy;
  float angle;
};

struct Material {
  vec3 baseColor;
  vec3 emissive;
  vec3 ambient;
  vec3 specular;
  float transparency;

  sampler2D baseColorMap;
  sampler2D emissiveMap;
  sampler2D ambientMap;
  sampler2D specularMap;
  sampler2D transparencyMap;
  sampler2D bumpMap;
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

layout(std140) uniform uboLightsInfo {
  Light uniLights[MAX_LIGHT_COUNT];
  uint uniLightCount;
};

uniform Material uniMaterial;

layout(location = 0) out vec4 fragColor;
layout(location = 1) out vec3 fragNormal;

void main() {
  vec3 normal = vertMeshInfo.vertTBNMatrix[2];

  float lightHitAngle = 0.0;

  for (uint lightIndex = 0u; lightIndex < uniLightCount; ++lightIndex) {
    vec3 lightPos = (uniViewProjectionMat * uniLights[lightIndex].position).xyz;
    vec3 lightDir;

    if (uniLights[lightIndex].position.w != 0.0)
      lightDir = normalize(lightPos - vertMeshInfo.vertPosition);
    else
      lightDir = normalize(-uniLights[lightIndex].direction.xyz);

    lightHitAngle = max(lightHitAngle, clamp(dot(lightDir, normal), 0.0, 1.0));
  }

  vec3 diffuse  = lightHitAngle * texture(uniMaterial.baseColorMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.baseColor;
  vec3 emissive = texture(uniMaterial.emissiveMap, vertMeshInfo.vertTexcoords).rgb * uniMaterial.emissive;

  fragColor  = vec4(diffuse + emissive, 1.0);
  fragNormal = normal;
}
layout(local_size_x = 1, local_size_y = 1, local_size_x = 1) in;

layout(r16f, binding = 0) uniform writeonly image1D uniNoiseMap;
uniform float uniNoiseFactor = 0.01;
uniform int uniOctaveCount   = 1;

const int permutations[512] = int[](
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
  8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
  35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
  55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
  18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
  250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
  189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
  172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
  228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
  107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
);

float smootherstep(float value) {
  return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);
}

float recoverGradient1D(int x) {
  return (permutations[x] % 2 == 0 ? 1.0 : -1.0);
}

float computePerlin(float coord) {
  // Determining coordinates on the line
  //
  //  x0---------x0+1

  int intX = int(coord);

  int x0 = intX & 255;

  float leftGrad  = recoverGradient1D(x0);
  float rightGrad = recoverGradient1D(x0 + 1);

  // Computing the distance to the coordinate
  //
  //  |------X--|
  //      xWeight

  float xWeight = coord - float(intX);

  float leftDot  = xWeight * leftGrad;
  float rightDot = (xWeight - 1) * rightGrad;

  float smoothX = smootherstep(xWeight);

  return mix(leftDot, rightDot, smoothX);
}

float computeFbm(float coord, int octaveCount) {
  float frequency = 1.0;
  float amplitude = 1.0;
  float total     = 0.0;

  for (int i = 0; i < octaveCount; ++i) {
    total += computePerlin(coord * frequency) * amplitude;

    frequency *= 2.0;
    amplitude *= 0.5;
  }

  return (total + 1.0) / 2.0;
}

void main() {
  float noise = computeFbm(float(gl_GlobalInvocationID.x) * uniNoiseFactor, uniOctaveCount);

  int pixelCoord = int(gl_GlobalInvocationID.x);
  imageStore(uniNoiseMap, pixelCoord, vec4(vec3(noise), 1.0));
}
struct Material {
  sampler2D baseColorMap;
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

uniform Material uniMaterial;

layout(location = 0) out vec4 fragColor;

void main() {
  fragColor = vec4(texture(uniMaterial.baseColorMap, vertMeshInfo.vertTexcoords).rgb, 1.0);
}
struct Material {
  sampler3D baseColorMap;
};

in struct MeshInfo {
  vec3 vertPosition;
  vec2 vertTexcoords;
  mat3 vertTBNMatrix;
} vertMeshInfo;

uniform Material uniMaterial;
uniform float uniDepth;

layout(location = 0) out vec4 fragColor;

void main() {
  fragColor = vec4(texture(uniMaterial.baseColorMap, vec3(vertMeshInfo.vertTexcoords, uniDepth)).rgb, 1.0);
}
struct Buffers {
  sampler2D depth;
  sampler2D color;
  sampler2D normal;
};

in vec2 fragTexcoords;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

uniform Buffers uniSceneBuffers;

layout(location = 0) out vec4 fragColor;

const uint ssaoCount    = 32u;
const float goldenRatio = (2.236 + 1.0) / 2.0;

#define PI 3.1415926535897932384626433832795

float rand(vec2 vec) {
  return fract(sin(dot(vec.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float copysign(float a, float b) {
  a = abs(a);

  if (b < 0)
    a = -a;

  return a;
}

void buildOrthoBase(vec3 normal, out vec3 xAxis, out vec3 zAxis) {
  float sign = copysign(1.0, normal.z);
  float a    = -1.0 / (sign + normal.z);
  float b    = normal.x * normal.y * a;

  xAxis = vec3(1.0 + sign * normal.x * normal.x * a, sign * b, -sign * normal.x);
  zAxis = vec3(b, sign + normal.y * normal.y * a, -normal.y);
}

vec3 computeFiboDir(vec3 normal, uint raySample) {
  float cosTheta = 1.0 - ((2.0 * float(raySample) + 1.0) / (2.0 * float(ssaoCount)));
  float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));

  float randVal = (raySample + rand(normal.xz)) / goldenRatio;
  float phi     = 2.0 * PI * (randVal - floor(randVal));

  vec3 direction = vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);

  vec3 xAxis, zAxis;
  buildOrthoBase(normal, xAxis, zAxis);

  return direction.x * xAxis + direction.y * normal + direction.z * zAxis;
}

float computeSsaoFactor(vec3 viewPos, vec3 worldNormal, float depth) {
  vec3 rayOrig   = viewPos + worldNormal * 0.0001;
  float hitCount = 0.0;

  for (uint raySample = 0u; raySample < ssaoCount; ++raySample) {
    vec3 rayDir   = computeFiboDir(worldNormal, raySample);
    float randVal = rand(viewPos.xy * raySample) * 50;
    vec3 rayStep  = rayOrig + randVal * rayDir;

    vec4 projCoords = uniProjectionMat * vec4(rayStep, 1.0);
    projCoords     /= projCoords.w;

    vec2 hitCoords = projCoords.xy * 0.5 + 0.5;
    float hitDepth = texture(uniSceneBuffers.depth, hitCoords).r;

    if (hitDepth > depth)
      ++hitCount;
  }

  float coeff = hitCount / ssaoCount;
  return clamp(pow(coeff, 0.5), 0, 1);
}

vec3 computeViewPosFromDepth(vec2 texcoords, float depth) {
  vec4 projPos = vec4(vec3(texcoords, depth) * 2.0 - 1.0, 1.0);
  vec4 viewPos = uniInvProjectionMat * projPos;

  return viewPos.xyz / viewPos.w;
}

void main() {
  float depth = texture(uniSceneBuffers.depth, fragTexcoords).r;

  vec3 viewPos  = computeViewPosFromDepth(fragTexcoords, depth);
  vec3 worldPos = vec3(uniInvViewMat * vec4(viewPos, 1.0));

  vec3 worldNormal = normalize(texture(uniSceneBuffers.normal, fragTexcoords).xyz * 2.0 - 1.0);

  if (gl_FragCoord.x < 640) {
    float ssaoFactor = computeSsaoFactor(viewPos, worldNormal, depth);
    fragColor = vec4(vec3(ssaoFactor), 1.0);
  } else {
    fragColor = vec4(texture(uniSceneBuffers.color, fragTexcoords).rgb, 1.0);
  }
}
struct Buffers {
  sampler2D depth;
  sampler2D color;
  sampler2D normal;
};

in vec2 fragTexcoords;

layout(std140) uniform uboCameraInfo {
  mat4 uniViewMat;
  mat4 uniInvViewMat;
  mat4 uniProjectionMat;
  mat4 uniInvProjectionMat;
  mat4 uniViewProjectionMat;
  vec3 uniCameraPos;
};

uniform Buffers uniSceneBuffers;

layout(location = 0) out vec4 fragColor;

const uint maxRaySteps    = 500u;
const uint maxBinarySteps = 5u;

vec3 binaryRefinement(vec3 rayDir, vec3 viewPos) {
  vec4 projCoords;

  for (uint binStep = 0u; binStep < maxBinarySteps; ++binStep) {
    projCoords     = uniProjectionMat * vec4(viewPos, 1.0);
    projCoords.xy /= projCoords.w;
    projCoords.xy  = projCoords.xy * 0.5 + 0.5;

    float depth     = texture(uniSceneBuffers.depth, projCoords.xy).r;
    float depthDiff = viewPos.z - depth;

    rayDir *= 0.5;

    if (depthDiff > 0.0)
      viewPos += rayDir;
    else
      viewPos -= rayDir;
  }

  projCoords     = uniProjectionMat * vec4(viewPos, 1.0);
  projCoords.xy /= projCoords.w;
  projCoords.xy  = projCoords.xy * 0.5 + 0.5;

  return texture(uniSceneBuffers.color, projCoords.xy).rgb;
}

vec3 recoverReflectColor(vec3 rayDir, vec3 viewPos) {
  rayDir *= 0.5;

  for (uint rayStep = 0u; rayStep < maxRaySteps; ++rayStep) {
    viewPos += rayDir;

    vec4 projCoords = uniProjectionMat * vec4(viewPos, 1.0);
    projCoords.xy  /= projCoords.w;
    projCoords.xy   = projCoords.xy * 0.5 + 0.5;

    float depth     = texture(uniSceneBuffers.depth, projCoords.xy).r;
    float depthDiff = viewPos.z - depth;

    if (depthDiff < 0.0)
      return texture(uniSceneBuffers.color, projCoords.xy).rgb;
      //return binaryRefinement(rayDir, viewPos);
  }

  return vec3(0.0);
}

vec3 computeViewPosFromDepth(vec2 texcoords, float depth) {
  vec4 projPos = vec4(vec3(texcoords, depth) * 2.0 - 1.0, 1.0);
  vec4 viewPos = uniInvProjectionMat * projPos;

  return viewPos.xyz / viewPos.w;
}

void main() {
  vec4 pixelColor     = texture(uniSceneBuffers.color, fragTexcoords).rgba;
  vec3 reflectColor   = pixelColor.rgb;
  float reflectFactor = pixelColor.a;

  if (reflectFactor > 0.1) {
    float depth = texture(uniSceneBuffers.depth, fragTexcoords).r;

    vec3 viewPos     = computeViewPosFromDepth(fragTexcoords, depth);
    vec3 worldNormal = normalize(texture(uniSceneBuffers.normal, fragTexcoords).xyz * 2.0 - 1.0);
    vec3 reflectDir  = normalize(reflect(normalize(viewPos), worldNormal));

    reflectColor *= 1.0 - reflectFactor;
    reflectColor += recoverReflectColor(vec3(reflectDir.xy, -reflectDir.z) * max(0.1, -viewPos.z), viewPos.xyz) * reflectFactor;
  }

  fragColor = vec4(reflectColor, 1.0);
}
in vec2 fragTexcoords;

uniform sampler2D uniBuffer;
uniform float uniFrameRatio;
uniform float uniStrength;
uniform float uniOpacity;
uniform vec3 uniColor;

layout(location = 0) out vec4 fragColor;

void main() {
  // Natural vignetting/illumination falloff, using the cosine fourth law. See:
  // - https://www.shadertoy.com/view/4lSXDm
  // - https://github.com/keijiro/KinoVignette/blob/master/Assets/Kino/Vignette/Shader/Vignette.shader
  // - https://en.wikipedia.org/wiki/Vignetting#Natural_vignetting
  // - https://www.cs.cmu.edu/~sensing-sensors/readings/vignetting.pdf#page=3

  vec2 uv     = (fragTexcoords - 0.5) * vec2(uniFrameRatio, 1.0) * 2.0;
  float len   = length(uv) * uniStrength;
  float sqLen = len * len + 1.0;
  float fade  = 1.0 / (sqLen * sqLen);

  // The following implementation may be another solution, but produces hard borders. See:
  // - https://www.shadertoy.com/view/lsKSWR
  // - https://godotshaders.com/shader/color-vignetting/

  //vec2 uv    = fragTexcoords * (1.0 - fragTexcoords);
  //float fade = uv.x * uv.y * 15.0;
  //fade       = pow(fade, uniStrength);

  vec3 color      = texture(uniBuffer, fragTexcoords).rgb;
  vec3 fadedColor = mix(color, uniColor, 1.0 - fade);

  fragColor = vec4(mix(color, fadedColor, uniOpacity), 1.0);
}
layout(local_size_x = 1, local_size_y = 1, local_size_x = 1) in;

layout(r16f, binding = 0) uniform writeonly image2D uniNoiseMap;
uniform float uniNoiseFactor = 0.01;

const vec2 offsets[9] = vec2[](
  vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0),
  vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
  vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0)
);

vec2 hash(vec2 vec) {
  // "Hash without Sine", from https://www.shadertoy.com/view/4djSRW
  vec3 v3 = fract(vec3(vec.xyx) * vec3(0.1031, 0.1030, 0.0973));
  v3     += dot(v3, v3.yzx + 33.33);
  return fract((v3.xx + v3.yz) * v3.zy);
}

float computeWorley(vec2 coords) {
  vec2 intCoords   = floor(coords);
  vec2 fractCoords = coords - intCoords; // fract(coords)

  float minSqDist = 1.0;

  for (int i = 0; i < 9; ++i) {
    vec2 cellCoords   = hash(intCoords + offsets[i]);
    vec2 cellPoint    = cellCoords + offsets[i] - fractCoords;
    float pointSqDist = dot(cellPoint, cellPoint);

    minSqDist = min(minSqDist, pointSqDist);
  }

  return sqrt(minSqDist);
}

void main() {
  float noise = computeWorley(vec2(gl_GlobalInvocationID.xy) * uniNoiseFactor);

  ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
  imageStore(uniNoiseMap, pixelCoords, vec4(vec3(noise), 1.0));
}
layout(local_size_x = 1, local_size_y = 1, local_size_x = 1) in;

layout(r16f, binding = 0) uniform writeonly image3D uniNoiseMap;
uniform float uniNoiseFactor = 0.01;

const vec3 offsets[27] = vec3[](
  vec3(-1.0,  1.0, -1.0), vec3(0.0,  1.0, -1.0), vec3(1.0,  1.0, -1.0),
  vec3(-1.0,  0.0, -1.0), vec3(0.0,  0.0, -1.0), vec3(1.0,  0.0, -1.0),
  vec3(-1.0, -1.0, -1.0), vec3(0.0, -1.0, -1.0), vec3(1.0, -1.0, -1.0),

  vec3(-1.0,  1.0, 0.0), vec3(0.0,  1.0, 0.0), vec3(1.0,  1.0, 0.0),
  vec3(-1.0,  0.0, 0.0), vec3(0.0,  0.0, 0.0), vec3(1.0,  0.0, 0.0),
  vec3(-1.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0), vec3(1.0, -1.0, 0.0),

  vec3(-1.0,  1.0, 1.0), vec3(0.0,  1.0, 1.0), vec3(1.0,  1.0, 1.0),
  vec3(-1.0,  0.0, 1.0), vec3(0.0,  0.0, 1.0), vec3(1.0,  0.0, 1.0),
  vec3(-1.0, -1.0, 1.0), vec3(0.0, -1.0, 1.0), vec3(1.0, -1.0, 1.0)
);

vec3 hash(vec3 vec) {
  // "Hash without Sine", from https://www.shadertoy.com/view/4djSRW
  vec  = fract(vec * vec3(0.1031, 0.1030, 0.0973));
  vec += dot(vec, vec.yxz + 33.33);
  return fract((vec.xxy + vec.yxx) * vec.zyx);
}

float computeWorley(vec3 coords) {
  vec3 intCoords   = floor(coords);
  vec3 fractCoords = coords - intCoords; // fract(coords)

  float minSqDist = 1.0;

  for (int i = 0; i < 27; ++i) {
    vec3 cellCoords   = hash(intCoords + offsets[i]);
    vec3 cellPoint    = cellCoords + offsets[i] - fractCoords;
    float pointSqDist = dot(cellPoint, cellPoint);

    minSqDist = min(minSqDist, pointSqDist);
  }

  return sqrt(minSqDist);
}

void main() {
  float noise = computeWorley(vec3(gl_GlobalInvocationID.xyz) * uniNoiseFactor);

  ivec3 pixelCoords = ivec3(gl_GlobalInvocationID.xyz);
  imageStore(uniNoiseMap, pixelCoords, vec4(vec3(noise), 1.0));
}
